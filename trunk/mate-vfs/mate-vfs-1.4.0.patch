diff -ur mate-vfs-1.4.0/daemon/daemon-connection.c mate-vfs-1.4.0-edited/daemon/daemon-connection.c
--- mate-vfs-1.4.0/daemon/daemon-connection.c	2012-07-05 17:22:56.000000000 +0000
+++ mate-vfs-1.4.0-edited/daemon/daemon-connection.c	2013-05-27 14:41:13.971279312 +0000
@@ -67,14 +67,14 @@
 	gint32            id;
 } FileHandle;
 
-static GStaticMutex cancellations_lock = G_STATIC_MUTEX_INIT;
+G_LOCK_DEFINE_STATIC(cancellations);
 static GHashTable *cancellations;
 
-static GStaticMutex directory_handles_lock = G_STATIC_MUTEX_INIT;
+G_LOCK_DEFINE_STATIC(directory_handles);
 static GHashTable *directory_handles;
 static guint next_directory_id = 1;
 
-static GStaticMutex file_handles_lock = G_STATIC_MUTEX_INIT;
+G_LOCK_DEFINE_STATIC(file_handles);
 static GHashTable *file_handles;
 static guint next_file_id = 1;
 
@@ -239,21 +239,21 @@
 	}
 	dbus_connection_unref (conn->conn);
 
-	g_static_mutex_lock (&directory_handles_lock);
+	G_LOCK (directory_handles);
 	if (directory_handles) {
 		g_hash_table_foreach_remove (directory_handles,
 					     directory_handle_last_conn_is,
 					     conn);
 	}
-	g_static_mutex_unlock (&directory_handles_lock);
+	G_UNLOCK (directory_handles);
 	
-	g_static_mutex_lock (&file_handles_lock);
+	G_LOCK (file_handles);
 	if (file_handles) {
 		g_hash_table_foreach_remove (file_handles,
 					     file_handle_last_conn_is,
 					     conn);
 	}
-	g_static_mutex_unlock (&file_handles_lock);
+	G_UNLOCK (file_handles);
 	
 	g_assert (!g_main_loop_is_running (conn->main_loop));
 
@@ -320,14 +320,14 @@
 
 	handle = cancellation_handle_new (id, conn->conn_id);
 	
-	g_static_mutex_lock (&cancellations_lock);
+	G_LOCK (cancellations);
 	if (cancellations == NULL) {
 		cancellations = g_hash_table_new_full (cancellation_handle_hash, cancellation_handle_equal,
 						       NULL, (GDestroyNotify) cancellation_handle_free);
 	}
 	
 	g_hash_table_insert (cancellations, handle, handle);
-	g_static_mutex_unlock (&cancellations_lock);
+	G_UNLOCK (cancellations);
 
 	return handle;
 }
@@ -338,11 +338,11 @@
 {
 	d(g_print ("Removing cancellation handle %d\n", handle->id));
 
-	g_static_mutex_lock (&cancellations_lock);
+	G_LOCK (cancellations);
 	if (!g_hash_table_remove (cancellations, handle)) {
 		g_warning ("Could't remove cancellation.");
 	}
-	g_static_mutex_unlock (&cancellations_lock);
+	G_UNLOCK (cancellations);
 }
 
 /* Note: This is called from the main thread. */
@@ -354,7 +354,7 @@
 
 	handle = NULL;
 
-	g_static_mutex_lock (&cancellations_lock);
+	G_LOCK (cancellations);
 	
 	lookup.conn_id = conn_id;
 	lookup.id = cancellation_id;
@@ -368,7 +368,7 @@
 		}
 	}
 	
-	g_static_mutex_unlock (&cancellations_lock);
+	G_UNLOCK (cancellations);
 }
 
 
@@ -408,7 +408,7 @@
 {
 	DirectoryHandle *handle;
 
-	g_static_mutex_lock (&directory_handles_lock);
+	G_LOCK (directory_handles);
 	handle = directory_handle_new (conn, vfs_handle, next_directory_id++);
 
 	if (directory_handles == NULL) {
@@ -418,7 +418,7 @@
 	
 	g_hash_table_insert (directory_handles,
 			     GINT_TO_POINTER (handle->id), handle);
-	g_static_mutex_unlock (&directory_handles_lock);
+	G_UNLOCK (directory_handles);
 
 	return handle;
 }
@@ -426,13 +426,13 @@
 static void
 remove_directory_handle (DirectoryHandle  *handle)
 {
-	g_static_mutex_lock (&directory_handles_lock);
+	G_LOCK (directory_handles);
 	if (!g_hash_table_remove (directory_handles,
 				  GINT_TO_POINTER (handle->id))) {
 		g_warning ("Couldn't remove directory handle %d\n",
 			   handle->id);
 	}
-	g_static_mutex_unlock (&directory_handles_lock);
+	G_UNLOCK (directory_handles);
 }
 
 static DirectoryHandle *
@@ -441,13 +441,13 @@
 {
 	DirectoryHandle *handle;
 	
-	g_static_mutex_lock (&directory_handles_lock);
+	G_LOCK (directory_handles);
 	handle = g_hash_table_lookup (directory_handles,
 				      GINT_TO_POINTER (id));
 	if (handle) {
 		handle->last_connection = conn;
 	}
-	g_static_mutex_unlock (&directory_handles_lock);
+	G_UNLOCK (directory_handles);
 	return handle;
 }
 
@@ -487,7 +487,7 @@
 {
 	FileHandle *handle;
 
-	g_static_mutex_lock (&file_handles_lock);
+	G_LOCK (file_handles);
 	handle = file_handle_new (conn, vfs_handle, next_file_id++);
 
 	if (file_handles == NULL) {
@@ -497,7 +497,7 @@
 	
 	g_hash_table_insert (file_handles,
 			     GINT_TO_POINTER (handle->id), handle);
-	g_static_mutex_unlock (&file_handles_lock);
+	G_UNLOCK (file_handles);
 
 	return handle;
 }
@@ -505,12 +505,12 @@
 static void
 remove_file_handle (FileHandle       *handle)
 {
-	g_static_mutex_lock (&file_handles_lock);
+	G_LOCK (file_handles);
 	if (!g_hash_table_remove (file_handles,
 				  GINT_TO_POINTER (handle->id))) {
 		g_warning ("Couldn't remove file handle %d\n", handle->id);
 	}
-	g_static_mutex_unlock (&file_handles_lock);
+	G_UNLOCK (file_handles);
 }
 
 static FileHandle *
@@ -519,13 +519,13 @@
 {
 	FileHandle *handle;
 
-	g_static_mutex_lock (&file_handles_lock);
+	G_LOCK (file_handles);
 	handle = g_hash_table_lookup (file_handles,
 				      GINT_TO_POINTER (id));
 	if (handle) {
 		handle->last_connection = conn;
 	}
-	g_static_mutex_unlock (&file_handles_lock);
+	G_UNLOCK (file_handles);
 	
 	return handle;
 }
Only in mate-vfs-1.4.0-edited/daemon: daemon-connection.c~
diff -ur mate-vfs-1.4.0/libmatevfs/mate-vfs-async-job-map.c mate-vfs-1.4.0-edited/libmatevfs/mate-vfs-async-job-map.c
--- mate-vfs-1.4.0/libmatevfs/mate-vfs-async-job-map.c	2012-07-05 17:22:56.000000000 +0000
+++ mate-vfs-1.4.0-edited/libmatevfs/mate-vfs-async-job-map.c	2013-05-27 09:05:56.507361000 +0000
@@ -27,14 +27,14 @@
 #include <glib.h>
 
 /* job map bits guarded by this lock */
-static GStaticRecMutex async_job_map_lock = G_STATIC_REC_MUTEX_INIT;
+static GRecMutex async_job_map_lock;
 static guint async_job_map_next_id;
 static int async_job_map_locked = 0;
 static gboolean async_job_map_shutting_down;
 static GHashTable *async_job_map;
 
 /* callback map bits guarded by this lock */
-static GStaticMutex async_job_callback_map_lock = G_STATIC_MUTEX_INIT;
+G_LOCK_DEFINE_STATIC(async_job_callback_map);
 static GHashTable *async_job_callback_map;
 static guint async_job_callback_map_next_id;
 
@@ -161,7 +161,7 @@
 void 
 _mate_vfs_async_job_map_lock (void)
 {
-	g_static_rec_mutex_lock (&async_job_map_lock);
+	g_rec_mutex_lock (&async_job_map_lock);
 	async_job_map_locked++;
 }
 
@@ -169,7 +169,7 @@
 _mate_vfs_async_job_map_unlock (void)
 {
 	async_job_map_locked--;
-	g_static_rec_mutex_unlock (&async_job_map_lock);
+	g_rec_mutex_unlock (&async_job_map_lock);
 }
 
 void 
@@ -185,7 +185,7 @@
 {
 	MateVFSNotifyResult *notify_result;
 	
-	g_static_mutex_lock (&async_job_callback_map_lock);
+	G_LOCK (async_job_callback_map);
 	
 	if (async_job_callback_map == NULL) {
 		g_assert (async_job_map_shutting_down);
@@ -199,7 +199,7 @@
 	*valid = notify_result != NULL;
 	*cancelled = notify_result != NULL && notify_result->cancelled;
 
-	g_static_mutex_unlock (&async_job_callback_map_lock);
+	G_UNLOCK (async_job_callback_map);
 }
 
 gboolean 
@@ -207,7 +207,7 @@
 {
 	gboolean cancelled;
 
-	g_static_mutex_lock (&async_job_callback_map_lock);
+	G_LOCK (async_job_callback_map);
 
 	g_assert (!async_job_map_shutting_down);
 	
@@ -232,7 +232,7 @@
 		g_hash_table_insert (async_job_callback_map, GUINT_TO_POINTER (notify_result->callback_id),
 			notify_result);
 	}
-	g_static_mutex_unlock (&async_job_callback_map_lock);
+	G_UNLOCK (async_job_callback_map);
 	
 	return !cancelled;
 }
@@ -243,11 +243,11 @@
 	g_assert (async_job_callback_map != NULL);
 
 	JOB_DEBUG (("removing callback %d ", callback_id));
-	g_static_mutex_lock (&async_job_callback_map_lock);
+	G_LOCK (async_job_callback_map);
 
 	g_hash_table_remove (async_job_callback_map, GUINT_TO_POINTER (callback_id));
 
-	g_static_mutex_unlock (&async_job_callback_map_lock);
+	G_UNLOCK (async_job_callback_map);
 }
 
 static void
@@ -268,7 +268,7 @@
 void
 _mate_vfs_async_job_cancel_job_and_callbacks (MateVFSAsyncHandle *job_handle, MateVFSJob *job)
 {
-	g_static_mutex_lock (&async_job_callback_map_lock);
+	G_LOCK (async_job_callback_map);
 	
 	if (job != NULL) {
 		job->cancelled = TRUE;
@@ -282,18 +282,18 @@
 				      callback_map_cancel_one, job_handle);
 	}
 
-	g_static_mutex_unlock (&async_job_callback_map_lock);
+	G_UNLOCK (async_job_callback_map);
 }
 
 void
 async_job_callback_map_destroy (void)
 {
-	g_static_mutex_lock (&async_job_callback_map_lock);
+	G_LOCK (async_job_callback_map);
 
 	if (async_job_callback_map) {
 		g_hash_table_destroy (async_job_callback_map);
 		async_job_callback_map = NULL;
 	}
 
-	g_static_mutex_unlock (&async_job_callback_map_lock);
+	G_UNLOCK (async_job_callback_map);
 }
Only in mate-vfs-1.4.0-edited/libmatevfs: mate-vfs-async-job-map.c~
diff -ur mate-vfs-1.4.0/libmatevfs/mate-vfs-daemon-method.c mate-vfs-1.4.0-edited/libmatevfs/mate-vfs-daemon-method.c
--- mate-vfs-1.4.0/libmatevfs/mate-vfs-daemon-method.c	2012-07-05 17:22:56.000000000 +0000
+++ mate-vfs-1.4.0-edited/libmatevfs/mate-vfs-daemon-method.c	2013-05-27 14:32:30.670211935 +0000
@@ -82,7 +82,7 @@
 						       DBusMessage     *message,
 						       gpointer         data);
 
-static GStaticPrivate  local_connection_private = G_STATIC_PRIVATE_INIT;
+static GPrivate  local_connection_private = G_PRIVATE_INIT(g_free);
 
 
 static DBusObjectPathVTable connection_vtable = {
@@ -356,7 +356,7 @@
 static void
 private_connection_died (LocalConnection *connection)
 {
-	g_static_private_set (&local_connection_private, NULL, NULL);
+	g_private_set (&local_connection_private, NULL);
 }
 
 static LocalConnection *
@@ -370,7 +370,7 @@
 	dbus_int32_t conn_id;
 	LocalConnection *ret;
 
-	ret = g_static_private_get (&local_connection_private);
+	ret = g_private_get (&local_connection_private);
 	if (ret != NULL) {
 		return ret;
 	}
@@ -438,8 +438,8 @@
 	ret->conn_id = conn_id;
 	ret->handle = 0;
 
-	g_static_private_set (&local_connection_private,
-			      ret, destroy_private_connection);
+	g_private_set (&local_connection_private,
+			      ret);
 	
 	return ret;
 }
Only in mate-vfs-1.4.0-edited/libmatevfs: mate-vfs-daemon-method.c~
diff -ur mate-vfs-1.4.0/libmatevfs/mate-vfs-dbus-utils.c mate-vfs-1.4.0-edited/libmatevfs/mate-vfs-dbus-utils.c
--- mate-vfs-1.4.0/libmatevfs/mate-vfs-dbus-utils.c	2012-07-05 17:22:56.000000000 +0000
+++ mate-vfs-1.4.0-edited/libmatevfs/mate-vfs-dbus-utils.c	2013-05-27 14:34:15.518244904 +0000
@@ -187,16 +187,16 @@
 	return main_dbus;
 }
 
-static GStaticPrivate  daemon_connection_private = G_STATIC_PRIVATE_INIT;
+static GPrivate  daemon_connection_private = G_PRIVATE_INIT(g_free);
 
 DBusConnection *
 _mate_vfs_daemon_get_current_connection (void)
 {
-	return g_static_private_get (&daemon_connection_private);
+	return g_private_get (&daemon_connection_private);
 }
 
 void
 mate_vfs_daemon_set_current_connection (DBusConnection *conn)
 {
-	g_static_private_set (&daemon_connection_private, conn, NULL);
+	g_private_set (&daemon_connection_private, conn);
 }
Only in mate-vfs-1.4.0-edited/libmatevfs: mate-vfs-dbus-utils.c~
diff -ur mate-vfs-1.4.0/libmatevfs/mate-vfs-file-info.c mate-vfs-1.4.0-edited/libmatevfs/mate-vfs-file-info.c
--- mate-vfs-1.4.0/libmatevfs/mate-vfs-file-info.c	2012-07-05 17:22:56.000000000 +0000
+++ mate-vfs-1.4.0-edited/libmatevfs/mate-vfs-file-info.c	2013-05-27 09:14:41.801441748 +0000
@@ -31,7 +31,7 @@
 /* Mutex for making MateVFSFileInfo ref's/unref's atomic */
 /* Note that an atomic increment function (such as is present in NSPR) is preferable */
 /* FIXME: This mutex is probably not needed and might be causing performance issues */
-static GStaticMutex file_info_ref_lock = G_STATIC_MUTEX_INIT;
+G_LOCK_DEFINE_STATIC(file_info_ref);
 
 /* Register MateVFSFileInfo in the type system */
 GType 
@@ -83,9 +83,9 @@
 	g_return_if_fail (info != NULL);
 	g_return_if_fail (info->refcount > 0);
 
-	g_static_mutex_lock (&file_info_ref_lock);
+	G_LOCK(file_info_ref);
 	info->refcount += 1;
-	g_static_mutex_unlock (&file_info_ref_lock);
+	G_UNLOCK(file_info_ref);
 	
 }
 
@@ -101,9 +101,9 @@
 	g_return_if_fail (info != NULL);
 	g_return_if_fail (info->refcount > 0);
 
-	g_static_mutex_lock (&file_info_ref_lock);
+	G_LOCK(file_info_ref);
 	info->refcount -= 1;
-	g_static_mutex_unlock (&file_info_ref_lock);
+	G_UNLOCK(file_info_ref);
 
 	if (info->refcount == 0) {
 		mate_vfs_file_info_clear (info);
@@ -133,13 +133,13 @@
 	g_free (info->selinux_context);
 
 	/* Ensure the ref count is maintained correctly */
-	g_static_mutex_lock (&file_info_ref_lock);
+	G_LOCK(file_info_ref);
 
 	old_refcount = info->refcount;
 	memset (info, 0, sizeof (*info));
 	info->refcount = old_refcount;
 
-	g_static_mutex_unlock (&file_info_ref_lock);
+	G_UNLOCK(file_info_ref);
 }
 
 
@@ -182,7 +182,7 @@
 	 * want serialize access differently (or perhaps you shouldn't
 	 * use copy)
 	 */
-	g_static_mutex_lock (&file_info_ref_lock);
+	G_LOCK(file_info_ref);
 
 	old_refcount = dest->refcount;
 
@@ -199,7 +199,7 @@
 
 	dest->refcount = old_refcount;
 
-	g_static_mutex_unlock (&file_info_ref_lock);
+	G_UNLOCK(file_info_ref);
 
 }
 
Only in mate-vfs-1.4.0-edited/libmatevfs: mate-vfs-file-info.c~
diff -ur mate-vfs-1.4.0/libmatevfs/mate-vfs-init.c mate-vfs-1.4.0-edited/libmatevfs/mate-vfs-init.c
--- mate-vfs-1.4.0/libmatevfs/mate-vfs-init.c	2012-07-05 17:22:56.000000000 +0000
+++ mate-vfs-1.4.0-edited/libmatevfs/mate-vfs-init.c	2013-05-28 06:59:10.709973593 +0000
@@ -129,9 +129,6 @@
 		return FALSE;
 	}
 
- 	if (!g_thread_supported ())
- 		g_thread_init (NULL);
-
 	G_LOCK (vfs_already_initialized);
 
 	if (!vfs_already_initialized) {
@@ -242,9 +239,5 @@
 gboolean
 mate_vfs_is_primary_thread (void)
 {
-	if (g_thread_supported()) {
-		return GPOINTER_TO_UINT(g_private_get (private_is_primary_thread)) == 1;
-	} else {
-		return TRUE;
-	}
+	return GPOINTER_TO_UINT(g_private_get (private_is_primary_thread)) == 1;
 }
Only in mate-vfs-1.4.0-edited/libmatevfs: mate-vfs-init.c~
diff -ur mate-vfs-1.4.0/libmatevfs/mate-vfs-job.c mate-vfs-1.4.0-edited/libmatevfs/mate-vfs-job.c
--- mate-vfs-1.4.0/libmatevfs/mate-vfs-job.c	2012-07-05 17:22:56.000000000 +0000
+++ mate-vfs-1.4.0-edited/libmatevfs/mate-vfs-job.c	2013-05-27 12:28:08.181039964 +0000
@@ -43,7 +43,7 @@
 #include <string.h>
 #include <unistd.h>
 
-static GStaticPrivate job_private = G_STATIC_PRIVATE_INIT;
+static GPrivate job_private = G_PRIVATE_INIT(g_free); 
 
 #if MATE_VFS_JOB_DEBUG
 
@@ -1734,9 +1734,9 @@
 set_current_job (MateVFSJob *job)
 {
 	/* There shouldn't have been anything here. */
-	g_assert (g_static_private_get (&job_private) == NULL);
+	g_assert (g_private_get (&job_private) == NULL);
 
-	g_static_private_set (&job_private, job, NULL);
+	g_private_set (&job_private, job);
 
 	_mate_vfs_module_callback_use_stack_info (job->op->stack_info);
 	_mate_vfs_module_callback_set_in_async_thread (TRUE);
@@ -1745,7 +1745,7 @@
 static void
 clear_current_job (void)
 {
-	g_static_private_set (&job_private, NULL, NULL);
+	g_private_set (&job_private, NULL);
 
 	_mate_vfs_module_callback_clear_stacks ();
 }
@@ -1757,7 +1757,7 @@
 	
 	g_return_if_fail (context != NULL);
 
-	job = g_static_private_get (&job_private);
+	job = g_private_get (&job_private);
 
 	if (job != NULL) {
 		*context = job->op->context;
@@ -1777,7 +1777,7 @@
 	MateVFSJob *job;
 	MateVFSNotifyResult notify_result;
 
-	job = g_static_private_get (&job_private);
+	job = g_private_get (&job_private);
 
 	g_return_if_fail (job != NULL);
 
diff -ur mate-vfs-1.4.0/libmatevfs/mate-vfs-job.h mate-vfs-1.4.0-edited/libmatevfs/mate-vfs-job.h
--- mate-vfs-1.4.0/libmatevfs/mate-vfs-job.h	2012-07-05 17:22:56.000000000 +0000
+++ mate-vfs-1.4.0-edited/libmatevfs/mate-vfs-job.h	2013-05-27 08:29:16.202157140 +0000
@@ -55,13 +55,13 @@
 	struct timeval _tt;			\
 	gettimeofday(&_tt, NULL);		\
 	printf ("%ld:%6.ld ", _tt.tv_sec, _tt.tv_usec); \
-	g_static_mutex_lock (&debug_mutex);	\
+	g_mutex_lock (&debug_mutex);	\
 	fputs (__FUNCTION__, stdout);		\
 	printf (": %d ", __LINE__);		\
 	printf x;				\
 	fputc ('\n', stdout);			\
 	fflush (stdout);			\
-	g_static_mutex_unlock (&debug_mutex);	\
+	g_mutex_unlock (&debug_mutex);	\
 }G_STMT_END
 
 #endif
diff -ur mate-vfs-1.4.0/libmatevfs/mate-vfs-method.c mate-vfs-1.4.0-edited/libmatevfs/mate-vfs-method.c
--- mate-vfs-1.4.0/libmatevfs/mate-vfs-method.c	2012-07-05 17:22:56.000000000 +0000
+++ mate-vfs-1.4.0-edited/libmatevfs/mate-vfs-method.c	2013-05-27 12:33:18.108056562 +0000
@@ -63,7 +63,7 @@
 
 static GHashTable *module_hash = NULL;
 G_LOCK_DEFINE_STATIC (mate_vfs_method_init);
-static GStaticRecMutex module_hash_lock = G_STATIC_REC_MUTEX_INIT;
+static GRecMutex module_hash_lock;
 
 static GList *module_path_list = NULL;
 
diff -ur mate-vfs-1.4.0/libmatevfs/mate-vfs-module-callback.c mate-vfs-1.4.0-edited/libmatevfs/mate-vfs-module-callback.c
--- mate-vfs-1.4.0/libmatevfs/mate-vfs-module-callback.c	2012-07-05 17:22:56.000000000 +0000
+++ mate-vfs-1.4.0-edited/libmatevfs/mate-vfs-module-callback.c	2013-05-27 14:22:04.013161059 +0000
@@ -1,4 +1,4 @@
-/* -*- Mode: C; indent-tabs-mode: t; c-basic-offset: 8; tab-width: 8 -*- */
+/* -*- Mode: C; indent-tabs-mode: t; c-basic-offset: 9; tab-width: 8 -*- */
 /*
 
    Copyright (C) 2001 Eazel, Inc
@@ -59,7 +59,8 @@
 
 /* -- Global variables -- */
 
-static GStaticMutex callback_table_lock = G_STATIC_MUTEX_INIT;
+G_LOCK_DEFINE_STATIC(callback_table);
+
 static GHashTable *default_callbacks = NULL;
 static GHashTable *default_async_callbacks = NULL;
 static GHashTable *stack_tables_to_free = NULL;
@@ -69,7 +70,7 @@
 static GPrivate *in_async_thread_key;
 
 static GCond *async_callback_cond;
-static GStaticMutex async_callback_lock = G_STATIC_MUTEX_INIT;
+G_LOCK_DEFINE_STATIC(async_callback); 
 
 /* -- Helper functions -- */
 
@@ -120,12 +121,12 @@
 {
 	CallbackResponseData *response_data;
 
-	g_static_mutex_lock (&async_callback_lock);
+	G_LOCK(async_callback);
 	response_data = data;
 	response_data->done = TRUE;
 	g_cond_broadcast (async_callback_cond);
 
-	g_static_mutex_unlock (&async_callback_lock);
+	G_UNLOCK(async_callback);
 }
 
 static void
@@ -146,7 +147,7 @@
 	 * new mutexes and condition variables all the time.
 	 */
 
-	g_static_mutex_lock (&async_callback_lock);
+	G_LOCK(async_callback);
 	response_data.done = FALSE;
 	_mate_vfs_dispatch_module_callback (async_callback->callback,
 					    in, in_size,
@@ -155,11 +156,10 @@
 					    async_callback_response,
 					    &response_data);
 	while (!response_data.done) {
-		g_cond_wait (async_callback_cond,
-			     g_static_mutex_get_mutex (&async_callback_lock));
+		g_cond_wait (async_callback_cond, &G_LOCK_NAME(async_callback));
 	}
 
-	g_static_mutex_unlock (&async_callback_lock);
+	G_UNLOCK(async_callback);
 }
 
 static void
@@ -410,13 +410,13 @@
 
 	stack_table = specific;
 
-	g_static_mutex_lock (&callback_table_lock);
+	G_LOCK(callback_table);
 	if (stack_tables_to_free != NULL) {
 		g_hash_table_remove (stack_tables_to_free, stack_table);
 	} else {
 		stack_table = NULL;
 	}
-	g_static_mutex_unlock (&callback_table_lock);
+	G_UNLOCK(callback_table);
 
 	if (stack_table) {
 		clear_stack_table (stack_table);
@@ -443,11 +443,11 @@
 static void
 free_stack_tables_to_free (void)
 {
-	g_static_mutex_lock (&callback_table_lock);
+	G_LOCK(callback_table);
 	g_hash_table_foreach_remove (stack_tables_to_free, stack_table_free_hr_func , NULL);
 	g_hash_table_destroy (stack_tables_to_free);
 	stack_tables_to_free = NULL;
-	g_static_mutex_unlock (&callback_table_lock);
+	G_UNLOCK(callback_table);
 }
 
 void
@@ -467,7 +467,7 @@
 static void
 free_default_callbacks (void)
 {
-	g_static_mutex_lock (&callback_table_lock);
+	G_LOCK(callback_table);
 
 	clear_callback_table (default_callbacks);
 	g_hash_table_destroy (default_callbacks);
@@ -475,7 +475,7 @@
 	clear_callback_table (default_async_callbacks);
 	g_hash_table_destroy (default_async_callbacks);
 
-	g_static_mutex_unlock (&callback_table_lock);
+	G_UNLOCK(callback_table);
 }
 
 /* This function should only be called with the mutex held. */
@@ -496,23 +496,23 @@
 {
 	/* Initialize per-thread data, if needed. */
 	if (g_private_get (callback_stacks_key) == NULL) {
-		g_static_mutex_lock (&callback_table_lock);
+		G_LOCK(callback_table);
 		g_private_set (callback_stacks_key,
 				     g_hash_table_new (g_str_hash, g_str_equal));
 		g_hash_table_insert (stack_tables_to_free,
 				     g_private_get (callback_stacks_key),
 				     GINT_TO_POINTER (1));
-		g_static_mutex_unlock (&callback_table_lock);
+		G_UNLOCK(callback_table);
 	}
 
 	if (g_private_get (async_callback_stacks_key) == NULL) {
-		g_static_mutex_lock (&callback_table_lock);
+		G_LOCK(callback_table);
 		g_private_set (async_callback_stacks_key,
 				     g_hash_table_new (g_str_hash, g_str_equal));
 		g_hash_table_insert (stack_tables_to_free,
 				     g_private_get (async_callback_stacks_key),
 				     GINT_TO_POINTER (1));
-		g_static_mutex_unlock (&callback_table_lock);
+		G_UNLOCK(callback_table);
 	}
 }
 
@@ -618,12 +618,12 @@
 
 	callback_info = callback_info_new (callback, callback_data, destroy_notify);
 
-	g_static_mutex_lock (&callback_table_lock);
+	G_LOCK(callback_table);
 
 	initialize_global_if_needed ();
 	insert_callback_into_table (default_callbacks, callback_name, callback_info);
 
-	g_static_mutex_unlock (&callback_table_lock);
+	G_UNLOCK(callback_table);
 
 	callback_info_unref (callback_info);
 }
@@ -730,12 +730,12 @@
 
 	callback_info = async_callback_info_new (callback, callback_data, notify);
 
-	g_static_mutex_lock (&callback_table_lock);
+	G_LOCK(callback_table);
 
 	initialize_global_if_needed ();
 	insert_callback_into_table (default_async_callbacks, callback_name, callback_info); 
 
-	g_static_mutex_unlock (&callback_table_lock);
+	G_UNLOCK(callback_table);
 
 	callback_info_unref (callback_info);
 }
@@ -864,13 +864,13 @@
 			g_assert (callback != NULL);
 			callback_info_ref (callback);
 		} else {
-			g_static_mutex_lock (&callback_table_lock);
+			G_LOCK(callback_table);
 			initialize_global_if_needed ();
 			callback = g_hash_table_lookup (default_async_callbacks, callback_name);
 			if (callback != NULL) {
 				callback_info_ref (callback);
 			}
-			g_static_mutex_unlock (&callback_table_lock);
+			G_UNLOCK(callback_table);
 		}
 	}
 
@@ -883,13 +883,13 @@
 			g_assert (callback != NULL);
 			callback_info_ref (callback);
 		} else {
-			g_static_mutex_lock (&callback_table_lock);
+			G_LOCK(callback_table);
 			initialize_global_if_needed ();
 			callback = g_hash_table_lookup (default_callbacks, callback_name);
 			if (callback != NULL) {
 				callback_info_ref (callback);
 			}
-			g_static_mutex_unlock (&callback_table_lock);
+			G_UNLOCK(callback_table);
 		}
 	}
 
@@ -920,9 +920,9 @@
 	stack_info->current_callbacks = g_hash_table_new (g_str_hash, g_str_equal);
 	stack_info->current_async_callbacks = g_hash_table_new (g_str_hash, g_str_equal);
 
-	g_static_mutex_lock (&callback_table_lock);
+	G_LOCK(callback_table);
 	initialize_global_if_needed ();
-	g_static_mutex_unlock (&callback_table_lock);
+	G_UNLOCK(callback_table);
 
 	initialize_per_thread_if_needed ();
 	copy_callback_stack_tops (g_private_get (callback_stacks_key),
Only in mate-vfs-1.4.0-edited/libmatevfs: mate-vfs-module-callback.c~
diff -ur mate-vfs-1.4.0/libmatevfs/mate-vfs-resolve.c mate-vfs-1.4.0-edited/libmatevfs/mate-vfs-resolve.c
--- mate-vfs-1.4.0/libmatevfs/mate-vfs-resolve.c	2012-07-05 17:22:56.000000000 +0000
+++ mate-vfs-1.4.0-edited/libmatevfs/mate-vfs-resolve.c	2013-05-27 14:24:19.565165716 +0000
@@ -139,11 +139,11 @@
 restart_resolve (void)
 {
 	   static GTimeVal last_reload = { 0, 0 };
-	   static GStaticMutex mutex = G_STATIC_MUTEX_INIT;
+	   G_LOCK_DEFINE_STATIC(now);
 	   GTimeVal now;
 	   gboolean ret;
 
-	   g_static_mutex_lock (&mutex);
+	   G_LOCK(now);
 	   g_get_current_time (&now);
 	   
 	   if ((now.tv_sec - last_reload.tv_sec) > RELOAD_TIMEVAL) {
@@ -155,7 +155,7 @@
 			 ret = FALSE;
 	   }
 	
-	   g_static_mutex_unlock (&mutex);
+	   G_UNLOCK(now);
 	   return ret;
 }
 #else
Only in mate-vfs-1.4.0-edited/libmatevfs: mate-vfs-resolve.c~
diff -ur mate-vfs-1.4.0/modules/sftp-method.c mate-vfs-1.4.0-edited/modules/sftp-method.c
--- mate-vfs-1.4.0/modules/sftp-method.c	2012-07-05 17:22:56.000000000 +0000
+++ mate-vfs-1.4.0-edited/modules/sftp-method.c	2013-05-28 06:59:24.253972087 +0000
@@ -1488,8 +1488,6 @@
 			invoke_save_auth (uri, keyring, user_name, object, authtype, password);
 		}
 
-		if (!g_thread_supported ()) g_thread_init (NULL);
-
 		*connection = g_new0 (SftpConnection, 1);
 		(*connection)->ref_count = 1;
 		(*connection)->in_fd = in_fd;
Only in mate-vfs-1.4.0-edited/modules: sftp-method.c~
